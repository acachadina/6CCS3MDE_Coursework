/*
 * generated by Xtext 2.20.0
 */
package uk.ac.kcl.inf.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import uk.ac.kcl.inf.dotLanguage.DotLanguage
import uk.ac.kcl.inf.dotLanguage.Graph
import uk.ac.kcl.inf.dotLanguage.Digraph
import uk.ac.kcl.inf.dotLanguage.NodeDeclaration
import uk.ac.kcl.inf.dotLanguage.UndirectedEdgeDeclaration
import uk.ac.kcl.inf.dotLanguage.DirectedEdgeDeclaration
import uk.ac.kcl.inf.dotLanguage.NodeId
import uk.ac.kcl.inf.dotLanguage.NodeList

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class DotLanguageGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val model = resource.contents.head as DotLanguage
		
		val className = resource.deriveClassName
		fsa.generateFile(className + ".java", model.doGenerateClass(className))
		
				
	}
		
	def deriveClassName(Resource resource) {
		val originalFilename = resource.URI.lastSegment
		
		// string to the first dot
		originalFilename.substring(0, originalFilename.indexOf('.')).toFirstUpper + "Dot"
		
	}
	
	
	def doGenerateClass(DotLanguage program, String className) '''
		
		import dot.library.*;
		import java.util.HashMap;
		import java.util.ArrayList;
		
		
		public class «className» {
			public static void main (String args[]){
				DotFrame tf = new DotFrame();
				
				Dot dot = new Dot(tf){
					@Override
					
					public void run() {
					« program.graphs.map[generateGraphStatements].join("\n")»	
					addGraphs();
					}
					
				};
				
				dot.run();
			}
		}
		
	'''
		
	dispatch def generateGraphStatements(Graph graph) '''
		« graph.statements.map[generateGraphCreationStatements(graph)].join("\n")»
	'''
	
	dispatch def generateGraphStatements(Digraph digraph)'''
		« digraph.statements.map[generateGraphCreationStatements(digraph)].join("\n")»
	'''
	
	// GRAPHS: 
	dispatch def generateGraphCreationStatements(NodeDeclaration node, Graph graph)'''		
		«IF node.optionalAttributes === null»
			addNode("«graph.name»", "«node.nodeName.name»", null, false);
		«ELSE»
			HashMap<String, String> attr«node.nodeName.name» = new HashMap<>();
			«FOR attr : node.optionalAttributes.attr»
				attr«node.nodeName.name».put("«attr.attributeName»","«attr.attributeValue»");
			«ENDFOR »
			addNode("«graph.name»", "«node.nodeName.name»", attr«node.nodeName.name», false);
		«ENDIF»
	'''
	dispatch def generateGraphCreationStatements(UndirectedEdgeDeclaration edge, Graph graph)'''
		ArrayList<String> secondNodes = new ArrayList<>();
		«edge.secondNode.rightSideEdgeDeclaration»
		addEdge("«graph.name»", "«edge.firstNode.name»", secondNodes); 
	'''
	
	dispatch def getRightSideEdgeDeclaration(NodeId node)'''
		secondNodes.add("«node.name»");		
	'''
	
	dispatch def getRightSideEdgeDeclaration(NodeList nodeList)'''
		«FOR node : nodeList.nodes»
		 	secondNodes.add("«node.name»");		
		 «ENDFOR »
	'''
	
	//DIGRAPHS
	dispatch def generateGraphCreationStatements(NodeDeclaration node, Digraph digraph)'''
		«IF node.optionalAttributes === null»
			addNode("«digraph.name»", "«node.nodeName.name»", null, true);
		«ELSE»
			HashMap<String, String> attr«node.nodeName.name» = new HashMap<>();
			«FOR attr : node.optionalAttributes.attr»
				attr«node.nodeName.name».put("«attr.attributeName»","«attr.attributeValue»");
			«ENDFOR »
			addNode("«digraph.name»", "«node.nodeName.name»", attr«node.nodeName.name», true);
		«ENDIF»		
	'''
	
	dispatch def generateGraphCreationStatements(DirectedEdgeDeclaration edge, Digraph digraph)'''
		ArrayList<String> secondNodes = new ArrayList<>();
		«edge.secondNode.rightSideEdgeDeclaration»
		addEdge("«digraph.name»", "«edge.firstNode.name»", secondNames); 
	'''

		
}
